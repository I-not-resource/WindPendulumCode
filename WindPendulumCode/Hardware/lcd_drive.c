#include "lcd_drive.h"
#if      __LCD_ENABLE
////////////////////////////////////////////////////////////////////////////
//警告！！！
//此应用程序，专为5510优化设计
//因此不具备良好的兼容性
////////////////////////////////////////////////////////////////////////////
u16 POINT_COLOR = GREEN;	  //画笔颜色
u16 BACK_COLOR  = BLACK;  //背景色 

//管理LCD重要参数
//默认为竖屏
_lcd_dev lcddev;

/***************************************************************************
函数名称：LCD_WR_REG
函数功能：写寄存器函数
函数备注：
***************************************************************************/
void LCD_WR_REG(u16 regval)
{
	regval = regval;
	LCD -> LCD_REG = regval;
}

/***************************************************************************
函数名称：LCD_WR_DATA
函数功能：写LCD寄存器值
函数备注：
***************************************************************************/
void LCD_WR_DATA(u16 regval)
{
	regval = regval;
	LCD -> LCD_RAM = regval;
}

/***************************************************************************
函数名称：LCD_RD_DATA
函数功能：读LCD寄存器值
函数备注：
***************************************************************************/
u16 LCD_RD_DATA(void)
{
	vu16 ram;
	ram = LCD -> LCD_RAM;
	return ram;
}

/***************************************************************************
函数名称：LCD_WriteReg
函数功能：写寄存器
函数备注：
***************************************************************************/
void LCD_WriteReg(vu16 LCD_Reg,vu16 LCD_RegValue)
{
	LCD -> LCD_REG = LCD_Reg;
	LCD -> LCD_RAM = LCD_RegValue;
}

/***************************************************************************
函数名称：LCD_ReadReg
函数功能：读寄存器
函数备注：
***************************************************************************/
u16 LCD_ReadReg(vu16 LCD_Reg)
{
	LCD_WR_REG(LCD_Reg);
	Delay_us(5);
	return LCD_RD_DATA();
}

/***************************************************************************
函数名称：LCD_WriteRAM_Perepare
函数功能：开始写GRAM
函数备注：写入的是颜色值
***************************************************************************/
void LCD_WriteRAM_Prepare(void)
{
	LCD -> LCD_REG = lcddev.wramcmd;
}


/***************************************************************************
函数名称：LCD_WriteRAM
函数功能：LCD写GRAM
函数备注：写入的是颜色值
***************************************************************************/
void LCD_WriteRAM(u16 RGB_Code)
{							    
	LCD->LCD_RAM = RGB_Code;//写十六位GRAM
}

/***************************************************************************
函数名称：LCD_BGR2RGB
函数功能：LCD写Gram
函数备注：从ILI93xx读出的数据为GBR格式，而我们写入的时候为RGB格式。
返回值：RGB格式的颜色值
***************************************************************************/
u16 LCD_BGR2RGB(u16 c)
{
	u16  r,g,b,rgb;   
	b=(c>>0)&0x1f;
	g=(c>>5)&0x3f;
	r=(c>>11)&0x1f;	 
	rgb=(b<<11)+(g<<5)+(r<<0);		 
	return(rgb);
}

/***************************************************************************
函数名称：opt_delay
函数功能：当mdk -O1时间优化时需要设置
函数备注：
***************************************************************************/
void opt_delay(u8 i)
{
	while(i--);
}

/***************************************************************************
函数名称：LCD_ReadPoint
函数功能：读取个某点的颜色值
函数备注：
***************************************************************************/
u16 LCD_ReadPoint(u16 x,u16 y)
{
 	vu16 r=0,g=0,b=0;
	if(x>=lcddev.width||y>=lcddev.height)return 0; //超过了范围,直接返回		   
	LCD_SetCursor(x,y);	    
	LCD_WR_REG(0X2E00);                            //5510 发送读GRAM指令    
 	LCD_RD_DATA();									               //dummy Read	   
	opt_delay(2);	  
 	r=LCD_RD_DATA();  		  						           //实际坐标颜色
	opt_delay(2);	  
	b=LCD_RD_DATA(); 
	g=r&0XFF;		                                 //对5510,第一次读取的是RG的值,R在前,G在后,各占8位
	g<<=8; 
	return (((r>>11)<<11)|((g>>10)<<5)|(b>>11));   ///NT35510需要公式转换一下
}			 

/***************************************************************************
函数名称：LCD_DisplayOn
函数功能：LCD开启显示
函数备注：
***************************************************************************/
void LCD_DisplayOn(void)
{
  LCD_WR_REG(0X2900);	//开启显示
}	 

/***************************************************************************
函数名称：LCD_DisplayOff
函数功能：LCD关闭显示
函数备注：
***************************************************************************/
void LCD_DisplayOff(void)
{	   
  LCD_WR_REG(0X2800);	//关闭显示
} 

/***************************************************************************
函数名称：LCD_SetCursor
函数功能：设置光标位置
函数备注：
***************************************************************************/
void LCD_SetCursor(u16 Xpos, u16 Ypos)
{	 
		LCD_WR_REG(lcddev.setxcmd); 
		LCD_WR_DATA(Xpos>>8); 
		LCD_WR_REG(lcddev.setxcmd+1); 
		LCD_WR_DATA(Xpos&0XFF);	 
		LCD_WR_REG(lcddev.setycmd); 
		LCD_WR_DATA(Ypos>>8); 
		LCD_WR_REG(lcddev.setycmd+1); 
		LCD_WR_DATA(Ypos&0XFF);		
} 		 

/***************************************************************************
函数名称：LCD_Scan_Dir
函数功能：设置LCD的自动扫描方向
函数备注：其他函数可能会受到此函数设置的影响,
         所以,一般设置为L2R_U2D即可,如果设置为其他扫描方式,可能导致显示不正常.
				 L2R_U2D 
				 L2R_D2U 
				 R2L_U2D 
				 R2L_D2U 

				 U2D_L2R 
				 U2D_R2L
				 D2U_L2R 
				 D2U_R2L
***************************************************************************/
void LCD_Scan_Dir(u8 dir)
{
	u16 regval=0;
	u16 dirreg=0;
	u16 temp;  

  switch(dir)
  {
		case L2R_U2D:                   //从左到右,从上到下
			regval|=(0<<7)|(0<<6)|(0<<5); 
			break;
		case L2R_D2U:                   //从左到右,从下到上
			regval|=(1<<7)|(0<<6)|(0<<5); 
			break;
		case R2L_U2D:                   //从右到左,从上到下
			regval|=(0<<7)|(1<<6)|(0<<5); 
			break;
		case R2L_D2U:                   //从右到左,从下到上
			regval|=(1<<7)|(1<<6)|(0<<5); 
			break;	 
		case U2D_L2R:                   //从上到下,从左到右
			regval|=(0<<7)|(0<<6)|(1<<5); 
			break;
		case U2D_R2L:                   //从上到下,从右到左
			regval|=(0<<7)|(1<<6)|(1<<5); 
			break;
		case D2U_L2R:                   //从下到上,从左到右
			regval|=(1<<7)|(0<<6)|(1<<5); 
			break;
		case D2U_R2L:                   //从下到上,从右到左
      regval|=(1<<7)|(1<<6)|(1<<5); 
      break;	 
  }
		
  dirreg=0X3600;   
	LCD_WriteReg(dirreg,regval);
	
  if(regval&0X20)
  {
    if(lcddev.width<lcddev.height)                          //交换X,Y
    {
      temp=lcddev.width;
      lcddev.width=lcddev.height;
      lcddev.height=temp;
 			}
  }
   else  
  {
    if(lcddev.width>lcddev.height)                          //交换X,Y
    {
      temp=lcddev.width;
      lcddev.width=lcddev.height;
      lcddev.height=temp;
    }
  }  

  LCD_WR_REG(lcddev.setxcmd);  LCD_WR_DATA(0); 
  LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(0); 
  LCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA((lcddev.width-1)>>8); 
  LCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA((lcddev.width-1)&0XFF); 
  LCD_WR_REG(lcddev.setycmd);  LCD_WR_DATA(0); 
  LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(0); 
  LCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA((lcddev.height-1)>>8); 
  LCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA((lcddev.height-1)&0XFF);

}

/***************************************************************************
函数名称：LCD_DrawPoint
函数功能：画点
函数备注：
***************************************************************************/
void LCD_DrawPoint(u16 x,u16 y)
{
	LCD_SetCursor(x,y);		//设置光标位置 
	LCD_WriteRAM_Prepare();	//开始写入GRAM
	LCD->LCD_RAM=POINT_COLOR; 
}

/***************************************************************************
函数名称：LCD_Fast_DrawPoint
函数功能：快速画点
函数备注：
***************************************************************************/
void LCD_Fast_DrawPoint(u16 x,u16 y,u16 color)
{	   
  LCD_WR_REG(lcddev.setxcmd);  LCD_WR_DATA(x>>8);  
  LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(x&0XFF);	  
  LCD_WR_REG(lcddev.setycmd);  LCD_WR_DATA(y>>8);  
  LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(y&0XFF); 
		
  LCD->LCD_REG=lcddev.wramcmd; 
  LCD->LCD_RAM=color; 
}

/***************************************************************************
函数名称：LCD_Display_Dir
函数功能：设置LCD显示方向
函数备注：dir:0,竖屏；1,横屏
***************************************************************************/
void LCD_Display_Dir(u8 dir)
{
	if(dir==0)			                 //竖屏
	{
		lcddev.dir=0;	                 //竖屏

    lcddev.wramcmd=0X2C00;
    lcddev.setxcmd=0X2A00;
    lcddev.setycmd=0X2B00; 
    lcddev.width=480;
    lcddev.height=800;
	}
	else 				                   //横屏
	{	  				 
		lcddev.dir=1;	               //横屏

    lcddev.wramcmd=0X2C00;
    lcddev.setxcmd=0X2A00;
    lcddev.setycmd=0X2B00; 
    lcddev.width=800;
    lcddev.height=480;
	}

	LCD_Scan_Dir(DFT_SCAN_DIR);	      //默认扫描方向
}	
 
/***************************************************************************
函数名称：LCD_Set_Window
函数功能：设置窗口,并自动设置画点坐标到窗口左上角(sx,sy).
函数备注：
***************************************************************************/
void LCD_Set_Window(u16 sx,u16 sy,u16 width,u16 height)
{   
	width=sx+width-1;
	height=sy+height-1;
		
  LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(sx>>8);  
  LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(sx&0XFF);	  
  LCD_WR_REG(lcddev.setxcmd+2);LCD_WR_DATA(width>>8);   
  LCD_WR_REG(lcddev.setxcmd+3);LCD_WR_DATA(width&0XFF);   
  LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(sy>>8);   
  LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(sy&0XFF);  
  LCD_WR_REG(lcddev.setycmd+2);LCD_WR_DATA(height>>8);   
  LCD_WR_REG(lcddev.setycmd+3);LCD_WR_DATA(height&0XFF);  
}
/***************************************************************************
函数名称：LCD_Clear
函数功能：清屏函数
函数备注：
***************************************************************************/
void LCD_Clear(void)
{
	u32 index=0;      
	u32 totalpoint=lcddev.width;
	totalpoint*=lcddev.height; 			             //得到总点数
  LCD_SetCursor(0x00,0x0000);	                 //设置光标位置 
	LCD_WriteRAM_Prepare();     		             //开始写入GRAM	 	  
	for(index=0;index<totalpoint;index++)
	{
		LCD->LCD_RAM=BACK_COLOR;	
	}
} 



/***************************************************************************
函数名称：LCD_Init
函数功能：初始化lcd
函数备注：该初始化函数可以初始化各种ILI93XX液晶,但是其他函数是基于ILI9320的!!!
         在其他型号的驱动芯片上没有测试! 
***************************************************************************/
void LCD_Init(void)
{ 	
	vu32 i=0;
	
  GPIO_InitTypeDef               GPIO_InitStructure;
	FSMC_NORSRAMInitTypeDef        FSMC_NORSRAMInitStructure;
  FSMC_NORSRAMTimingInitTypeDef  readWriteTiming; 
	FSMC_NORSRAMTimingInitTypeDef  writeTiming;
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB|
	                       RCC_AHB1Periph_GPIOD|
												 RCC_AHB1Periph_GPIOE|
												 RCC_AHB1Periph_GPIOF|
												 RCC_AHB1Periph_GPIOG, ENABLE);        //使能PD,PE,PF,PG时钟  
  RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC,ENABLE);          //使能FSMC时钟  
	
 
	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_11;                 //PB15 推挽输出,控制背光
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;               //普通输出模式
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;               //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;            //100MHz
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;                //上拉
  GPIO_Init(GPIOB, &GPIO_InitStructure);                       //初始化 //PB15 推挽输出,控制背光
	
  GPIO_InitStructure.GPIO_Pin   = (3<<0)|(3<<4)|(7<<8)|(3<<14);//PD0,1,4,5,8,9,10,14,15 AF OUT
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;                //复用输出
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;               //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;           //100MHz
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;                //上拉
  GPIO_Init(GPIOD, &GPIO_InitStructure);                       //初始化  
	
  GPIO_InitStructure.GPIO_Pin   = (0X1FF<<7);                  //PE7~15,AF OUT
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;                //复用输出
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;               //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;           //100MHz
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;                //上拉
  GPIO_Init(GPIOE, &GPIO_InitStructure);                       //初始化  

	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12;                 //PF12,FSMC_A6
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;                //复用输出
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;               //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;           //100MHz
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;                //上拉
  GPIO_Init(GPIOF, &GPIO_InitStructure);                       //初始化  

	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_12;                 //PF12,FSMC_A6
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;                //复用输出
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;               //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;           //100MHz
  GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;                //上拉
  GPIO_Init(GPIOG, &GPIO_InitStructure);                       //初始化 

  GPIO_PinAFConfig(GPIOD,GPIO_PinSource0,GPIO_AF_FSMC);        //PD0,AF12
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource1,GPIO_AF_FSMC);        //PD1,AF12
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource4,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource5,GPIO_AF_FSMC); 
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource8,GPIO_AF_FSMC); 
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource9,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource10,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource14,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOD,GPIO_PinSource15,GPIO_AF_FSMC);       //PD15,AF12
 
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource7,GPIO_AF_FSMC);        //PE7,AF12
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource8,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource9,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource10,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource11,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource12,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource13,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource14,GPIO_AF_FSMC);
  GPIO_PinAFConfig(GPIOE,GPIO_PinSource15,GPIO_AF_FSMC);       //PE15,AF12
 
  GPIO_PinAFConfig(GPIOF,GPIO_PinSource12,GPIO_AF_FSMC);       //PF12,AF12
  GPIO_PinAFConfig(GPIOG,GPIO_PinSource12,GPIO_AF_FSMC);


  readWriteTiming.FSMC_AddressSetupTime      = 0XF;	               //地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns	
  readWriteTiming.FSMC_AddressHoldTime       = 0x00;	             //地址保持时间（ADDHLD）模式A未用到	
  readWriteTiming.FSMC_DataSetupTime         = 60;			           //数据保存时间为60个HCLK	=6*60=360ns
  readWriteTiming.FSMC_BusTurnAroundDuration = 0x00;
  readWriteTiming.FSMC_CLKDivision           = 0x00;
  readWriteTiming.FSMC_DataLatency           = 0x00;
  readWriteTiming.FSMC_AccessMode            = FSMC_AccessMode_A;	 //模式A 
    

	writeTiming.FSMC_AddressSetupTime          = 9;                  //地址建立时间（ADDSET）为9个HCLK =54ns 
  writeTiming.FSMC_AddressHoldTime           = 0x00;               //地址保持时间（A		
  writeTiming.FSMC_DataSetupTime             = 8;                  //数据保存时间为6ns*9个HCLK=54ns
  writeTiming.FSMC_BusTurnAroundDuration     = 0x00;
  writeTiming.FSMC_CLKDivision               = 0x00;
  writeTiming.FSMC_DataLatency               = 0x00;
  writeTiming.FSMC_AccessMode = FSMC_AccessMode_A;                 //模式A 

 
  FSMC_NORSRAMInitStructure.FSMC_Bank                  = FSMC_Bank1_NORSRAM4;                  //  这里我们使用NE4 ，也就对应BTCR[6],[7]。
  FSMC_NORSRAMInitStructure.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;          // 不复用数据地址
  FSMC_NORSRAMInitStructure.FSMC_MemoryType            = FSMC_MemoryType_SRAM;                 // FSMC_MemoryType_SRAM;  //SRAM   
  FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;             //存储器数据宽度为16bit   
  FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode       = FSMC_BurstAccessMode_Disable;         // FSMC_BurstAccessMode_Disable; 
  FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity    = FSMC_WaitSignalPolarity_Low;
	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait      = FSMC_AsynchronousWait_Disable; 
  FSMC_NORSRAMInitStructure.FSMC_WrapMode              = FSMC_WrapMode_Disable;   
  FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive      = FSMC_WaitSignalActive_BeforeWaitState;  
  FSMC_NORSRAMInitStructure.FSMC_WriteOperation        = FSMC_WriteOperation_Enable;	         //  存储器写使能
  FSMC_NORSRAMInitStructure.FSMC_WaitSignal            = FSMC_WaitSignal_Disable;   
  FSMC_NORSRAMInitStructure.FSMC_ExtendedMode          = FSMC_ExtendedMode_Enable;             // 读写使用不同的时序
  FSMC_NORSRAMInitStructure.FSMC_WriteBurst            = FSMC_WriteBurst_Disable; 
  FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &readWriteTiming;                     //读写时序
  FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct     = &writeTiming;                         //写时序

  FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);                                                //初始化FSMC配置

  FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);                                                // 使能BANK1 
		
 	Delay_ms(50); // delay 50 ms 
 	LCD_WriteReg(0x0000,0x0001);
	Delay_ms(50); // delay 50 ms 
 	lcddev.id = LCD_ReadReg(0x0000); 
 	if(lcddev.id<0XFF||lcddev.id==0XFFFF)//读到ID不正确
	{	

					LCD_WR_REG(0XDA00);	
					lcddev.id=LCD_RD_DATA();//读回0X00	 
					LCD_WR_REG(0XDB00);	
					lcddev.id=LCD_RD_DATA();//读回0X80
					lcddev.id<<=8;	
					LCD_WR_REG(0XDC00);	
					lcddev.id|=LCD_RD_DATA();//读回0X00		
					if(lcddev.id==0x8000)lcddev.id=0x5510;//NT35510读回的ID是8000H,为方便区分,我们强制设置为5510
	}   
	if(lcddev.id==0X5510)           //如果是这三个IC,则设置WR时序为最快
	{
		//重新配置写时序控制寄存器的时序   	 							    
		FSMC_Bank1E->BWTR[6]&=~(0XF<<0);//地址建立时间（ADDSET）清零 	 
		FSMC_Bank1E->BWTR[6]&=~(0XF<<8);//数据保存时间清零
		FSMC_Bank1E->BWTR[6]|=3<<0;		//地址建立时间（ADDSET）为3个HCLK =18ns  	 
		FSMC_Bank1E->BWTR[6]|=2<<8; 	//数据保存时间为6ns*3个HCLK=18ns
	}
  if(lcddev.id==0x5510)
	{
		LCD_WriteReg(0xF000,0x55);
		LCD_WriteReg(0xF001,0xAA);
		LCD_WriteReg(0xF002,0x52);
		LCD_WriteReg(0xF003,0x08);
		LCD_WriteReg(0xF004,0x01);
		//AVDD Set AVDD 5.2V
		LCD_WriteReg(0xB000,0x0D);
		LCD_WriteReg(0xB001,0x0D);
		LCD_WriteReg(0xB002,0x0D);
		//AVDD ratio
		LCD_WriteReg(0xB600,0x34);
		LCD_WriteReg(0xB601,0x34);
		LCD_WriteReg(0xB602,0x34);
		//AVEE -5.2V
		LCD_WriteReg(0xB100,0x0D);
		LCD_WriteReg(0xB101,0x0D);
		LCD_WriteReg(0xB102,0x0D);
		//AVEE ratio
		LCD_WriteReg(0xB700,0x34);
		LCD_WriteReg(0xB701,0x34);
		LCD_WriteReg(0xB702,0x34);
		//VCL -2.5V
		LCD_WriteReg(0xB200,0x00);
		LCD_WriteReg(0xB201,0x00);
		LCD_WriteReg(0xB202,0x00);
		//VCL ratio
		LCD_WriteReg(0xB800,0x24);
		LCD_WriteReg(0xB801,0x24);
		LCD_WriteReg(0xB802,0x24);
		//VGH 15V (Free pump)
		LCD_WriteReg(0xBF00,0x01);
		LCD_WriteReg(0xB300,0x0F);
		LCD_WriteReg(0xB301,0x0F);
		LCD_WriteReg(0xB302,0x0F);
		//VGH ratio
		LCD_WriteReg(0xB900,0x34);
		LCD_WriteReg(0xB901,0x34);
		LCD_WriteReg(0xB902,0x34);
		//VGL_REG -10V
		LCD_WriteReg(0xB500,0x08);
		LCD_WriteReg(0xB501,0x08);
		LCD_WriteReg(0xB502,0x08);
		LCD_WriteReg(0xC200,0x03);
		//VGLX ratio
		LCD_WriteReg(0xBA00,0x24);
		LCD_WriteReg(0xBA01,0x24);
		LCD_WriteReg(0xBA02,0x24);
		//VGMP/VGSP 4.5V/0V
		LCD_WriteReg(0xBC00,0x00);
		LCD_WriteReg(0xBC01,0x78);
		LCD_WriteReg(0xBC02,0x00);
		//VGMN/VGSN -4.5V/0V
		LCD_WriteReg(0xBD00,0x00);
		LCD_WriteReg(0xBD01,0x78);
		LCD_WriteReg(0xBD02,0x00);
		//VCOM
		LCD_WriteReg(0xBE00,0x00);
		LCD_WriteReg(0xBE01,0x64);
		//Gamma Setting
		LCD_WriteReg(0xD100,0x00);
		LCD_WriteReg(0xD101,0x33);
		LCD_WriteReg(0xD102,0x00);
		LCD_WriteReg(0xD103,0x34);
		LCD_WriteReg(0xD104,0x00);
		LCD_WriteReg(0xD105,0x3A);
		LCD_WriteReg(0xD106,0x00);
		LCD_WriteReg(0xD107,0x4A);
		LCD_WriteReg(0xD108,0x00);
		LCD_WriteReg(0xD109,0x5C);
		LCD_WriteReg(0xD10A,0x00);
		LCD_WriteReg(0xD10B,0x81);
		LCD_WriteReg(0xD10C,0x00);
		LCD_WriteReg(0xD10D,0xA6);
		LCD_WriteReg(0xD10E,0x00);
		LCD_WriteReg(0xD10F,0xE5);
		LCD_WriteReg(0xD110,0x01);
		LCD_WriteReg(0xD111,0x13);
		LCD_WriteReg(0xD112,0x01);
		LCD_WriteReg(0xD113,0x54);
		LCD_WriteReg(0xD114,0x01);
		LCD_WriteReg(0xD115,0x82);
		LCD_WriteReg(0xD116,0x01);
		LCD_WriteReg(0xD117,0xCA);
		LCD_WriteReg(0xD118,0x02);
		LCD_WriteReg(0xD119,0x00);
		LCD_WriteReg(0xD11A,0x02);
		LCD_WriteReg(0xD11B,0x01);
		LCD_WriteReg(0xD11C,0x02);
		LCD_WriteReg(0xD11D,0x34);
		LCD_WriteReg(0xD11E,0x02);
		LCD_WriteReg(0xD11F,0x67);
		LCD_WriteReg(0xD120,0x02);
		LCD_WriteReg(0xD121,0x84);
		LCD_WriteReg(0xD122,0x02);
		LCD_WriteReg(0xD123,0xA4);
		LCD_WriteReg(0xD124,0x02);
		LCD_WriteReg(0xD125,0xB7);
		LCD_WriteReg(0xD126,0x02);
		LCD_WriteReg(0xD127,0xCF);
		LCD_WriteReg(0xD128,0x02);
		LCD_WriteReg(0xD129,0xDE);
		LCD_WriteReg(0xD12A,0x02);
		LCD_WriteReg(0xD12B,0xF2);
		LCD_WriteReg(0xD12C,0x02);
		LCD_WriteReg(0xD12D,0xFE);
		LCD_WriteReg(0xD12E,0x03);
		LCD_WriteReg(0xD12F,0x10);
		LCD_WriteReg(0xD130,0x03);
		LCD_WriteReg(0xD131,0x33);
		LCD_WriteReg(0xD132,0x03);
		LCD_WriteReg(0xD133,0x6D);
		LCD_WriteReg(0xD200,0x00);
		LCD_WriteReg(0xD201,0x33);
		LCD_WriteReg(0xD202,0x00);
		LCD_WriteReg(0xD203,0x34);
		LCD_WriteReg(0xD204,0x00);
		LCD_WriteReg(0xD205,0x3A);
		LCD_WriteReg(0xD206,0x00);
		LCD_WriteReg(0xD207,0x4A);
		LCD_WriteReg(0xD208,0x00);
		LCD_WriteReg(0xD209,0x5C);
		LCD_WriteReg(0xD20A,0x00);

		LCD_WriteReg(0xD20B,0x81);
		LCD_WriteReg(0xD20C,0x00);
		LCD_WriteReg(0xD20D,0xA6);
		LCD_WriteReg(0xD20E,0x00);
		LCD_WriteReg(0xD20F,0xE5);
		LCD_WriteReg(0xD210,0x01);
		LCD_WriteReg(0xD211,0x13);
		LCD_WriteReg(0xD212,0x01);
		LCD_WriteReg(0xD213,0x54);
		LCD_WriteReg(0xD214,0x01);
		LCD_WriteReg(0xD215,0x82);
		LCD_WriteReg(0xD216,0x01);
		LCD_WriteReg(0xD217,0xCA);
		LCD_WriteReg(0xD218,0x02);
		LCD_WriteReg(0xD219,0x00);
		LCD_WriteReg(0xD21A,0x02);
		LCD_WriteReg(0xD21B,0x01);
		LCD_WriteReg(0xD21C,0x02);
		LCD_WriteReg(0xD21D,0x34);
		LCD_WriteReg(0xD21E,0x02);
		LCD_WriteReg(0xD21F,0x67);
		LCD_WriteReg(0xD220,0x02);
		LCD_WriteReg(0xD221,0x84);
		LCD_WriteReg(0xD222,0x02);
		LCD_WriteReg(0xD223,0xA4);
		LCD_WriteReg(0xD224,0x02);
		LCD_WriteReg(0xD225,0xB7);
		LCD_WriteReg(0xD226,0x02);
		LCD_WriteReg(0xD227,0xCF);
		LCD_WriteReg(0xD228,0x02);
		LCD_WriteReg(0xD229,0xDE);
		LCD_WriteReg(0xD22A,0x02);
		LCD_WriteReg(0xD22B,0xF2);
		LCD_WriteReg(0xD22C,0x02);
		LCD_WriteReg(0xD22D,0xFE);
		LCD_WriteReg(0xD22E,0x03);
		LCD_WriteReg(0xD22F,0x10);
		LCD_WriteReg(0xD230,0x03);
		LCD_WriteReg(0xD231,0x33);
		LCD_WriteReg(0xD232,0x03);
		LCD_WriteReg(0xD233,0x6D);
		LCD_WriteReg(0xD300,0x00);
		LCD_WriteReg(0xD301,0x33);
		LCD_WriteReg(0xD302,0x00);
		LCD_WriteReg(0xD303,0x34);
		LCD_WriteReg(0xD304,0x00);
		LCD_WriteReg(0xD305,0x3A);
		LCD_WriteReg(0xD306,0x00);
		LCD_WriteReg(0xD307,0x4A);
		LCD_WriteReg(0xD308,0x00);
		LCD_WriteReg(0xD309,0x5C);
		LCD_WriteReg(0xD30A,0x00);

		LCD_WriteReg(0xD30B,0x81);
		LCD_WriteReg(0xD30C,0x00);
		LCD_WriteReg(0xD30D,0xA6);
		LCD_WriteReg(0xD30E,0x00);
		LCD_WriteReg(0xD30F,0xE5);
		LCD_WriteReg(0xD310,0x01);
		LCD_WriteReg(0xD311,0x13);
		LCD_WriteReg(0xD312,0x01);
		LCD_WriteReg(0xD313,0x54);
		LCD_WriteReg(0xD314,0x01);
		LCD_WriteReg(0xD315,0x82);
		LCD_WriteReg(0xD316,0x01);
		LCD_WriteReg(0xD317,0xCA);
		LCD_WriteReg(0xD318,0x02);
		LCD_WriteReg(0xD319,0x00);
		LCD_WriteReg(0xD31A,0x02);
		LCD_WriteReg(0xD31B,0x01);
		LCD_WriteReg(0xD31C,0x02);
		LCD_WriteReg(0xD31D,0x34);
		LCD_WriteReg(0xD31E,0x02);
		LCD_WriteReg(0xD31F,0x67);
		LCD_WriteReg(0xD320,0x02);
		LCD_WriteReg(0xD321,0x84);
		LCD_WriteReg(0xD322,0x02);
		LCD_WriteReg(0xD323,0xA4);
		LCD_WriteReg(0xD324,0x02);
		LCD_WriteReg(0xD325,0xB7);
		LCD_WriteReg(0xD326,0x02);
		LCD_WriteReg(0xD327,0xCF);
		LCD_WriteReg(0xD328,0x02);
		LCD_WriteReg(0xD329,0xDE);
		LCD_WriteReg(0xD32A,0x02);
		LCD_WriteReg(0xD32B,0xF2);
		LCD_WriteReg(0xD32C,0x02);
		LCD_WriteReg(0xD32D,0xFE);
		LCD_WriteReg(0xD32E,0x03);
		LCD_WriteReg(0xD32F,0x10);
		LCD_WriteReg(0xD330,0x03);
		LCD_WriteReg(0xD331,0x33);
		LCD_WriteReg(0xD332,0x03);
		LCD_WriteReg(0xD333,0x6D);
		LCD_WriteReg(0xD400,0x00);
		LCD_WriteReg(0xD401,0x33);
		LCD_WriteReg(0xD402,0x00);
		LCD_WriteReg(0xD403,0x34);
		LCD_WriteReg(0xD404,0x00);
		LCD_WriteReg(0xD405,0x3A);
		LCD_WriteReg(0xD406,0x00);
		LCD_WriteReg(0xD407,0x4A);
		LCD_WriteReg(0xD408,0x00);
		LCD_WriteReg(0xD409,0x5C);
		LCD_WriteReg(0xD40A,0x00);
		LCD_WriteReg(0xD40B,0x81);

		LCD_WriteReg(0xD40C,0x00);
		LCD_WriteReg(0xD40D,0xA6);
		LCD_WriteReg(0xD40E,0x00);
		LCD_WriteReg(0xD40F,0xE5);
		LCD_WriteReg(0xD410,0x01);
		LCD_WriteReg(0xD411,0x13);
		LCD_WriteReg(0xD412,0x01);
		LCD_WriteReg(0xD413,0x54);
		LCD_WriteReg(0xD414,0x01);
		LCD_WriteReg(0xD415,0x82);
		LCD_WriteReg(0xD416,0x01);
		LCD_WriteReg(0xD417,0xCA);
		LCD_WriteReg(0xD418,0x02);
		LCD_WriteReg(0xD419,0x00);
		LCD_WriteReg(0xD41A,0x02);
		LCD_WriteReg(0xD41B,0x01);
		LCD_WriteReg(0xD41C,0x02);
		LCD_WriteReg(0xD41D,0x34);
		LCD_WriteReg(0xD41E,0x02);
		LCD_WriteReg(0xD41F,0x67);
		LCD_WriteReg(0xD420,0x02);
		LCD_WriteReg(0xD421,0x84);
		LCD_WriteReg(0xD422,0x02);
		LCD_WriteReg(0xD423,0xA4);
		LCD_WriteReg(0xD424,0x02);
		LCD_WriteReg(0xD425,0xB7);
		LCD_WriteReg(0xD426,0x02);
		LCD_WriteReg(0xD427,0xCF);
		LCD_WriteReg(0xD428,0x02);
		LCD_WriteReg(0xD429,0xDE);
		LCD_WriteReg(0xD42A,0x02);
		LCD_WriteReg(0xD42B,0xF2);
		LCD_WriteReg(0xD42C,0x02);
		LCD_WriteReg(0xD42D,0xFE);
		LCD_WriteReg(0xD42E,0x03);
		LCD_WriteReg(0xD42F,0x10);
		LCD_WriteReg(0xD430,0x03);
		LCD_WriteReg(0xD431,0x33);
		LCD_WriteReg(0xD432,0x03);
		LCD_WriteReg(0xD433,0x6D);
		LCD_WriteReg(0xD500,0x00);
		LCD_WriteReg(0xD501,0x33);
		LCD_WriteReg(0xD502,0x00);
		LCD_WriteReg(0xD503,0x34);
		LCD_WriteReg(0xD504,0x00);
		LCD_WriteReg(0xD505,0x3A);
		LCD_WriteReg(0xD506,0x00);
		LCD_WriteReg(0xD507,0x4A);
		LCD_WriteReg(0xD508,0x00);
		LCD_WriteReg(0xD509,0x5C);
		LCD_WriteReg(0xD50A,0x00);
		LCD_WriteReg(0xD50B,0x81);

		LCD_WriteReg(0xD50C,0x00);
		LCD_WriteReg(0xD50D,0xA6);
		LCD_WriteReg(0xD50E,0x00);
		LCD_WriteReg(0xD50F,0xE5);
		LCD_WriteReg(0xD510,0x01);
		LCD_WriteReg(0xD511,0x13);
		LCD_WriteReg(0xD512,0x01);
		LCD_WriteReg(0xD513,0x54);
		LCD_WriteReg(0xD514,0x01);
		LCD_WriteReg(0xD515,0x82);
		LCD_WriteReg(0xD516,0x01);
		LCD_WriteReg(0xD517,0xCA);
		LCD_WriteReg(0xD518,0x02);
		LCD_WriteReg(0xD519,0x00);
		LCD_WriteReg(0xD51A,0x02);
		LCD_WriteReg(0xD51B,0x01);
		LCD_WriteReg(0xD51C,0x02);
		LCD_WriteReg(0xD51D,0x34);
		LCD_WriteReg(0xD51E,0x02);
		LCD_WriteReg(0xD51F,0x67);
		LCD_WriteReg(0xD520,0x02);
		LCD_WriteReg(0xD521,0x84);
		LCD_WriteReg(0xD522,0x02);
		LCD_WriteReg(0xD523,0xA4);
		LCD_WriteReg(0xD524,0x02);
		LCD_WriteReg(0xD525,0xB7);
		LCD_WriteReg(0xD526,0x02);
		LCD_WriteReg(0xD527,0xCF);
		LCD_WriteReg(0xD528,0x02);
		LCD_WriteReg(0xD529,0xDE);
		LCD_WriteReg(0xD52A,0x02);
		LCD_WriteReg(0xD52B,0xF2);
		LCD_WriteReg(0xD52C,0x02);
		LCD_WriteReg(0xD52D,0xFE);
		LCD_WriteReg(0xD52E,0x03);
		LCD_WriteReg(0xD52F,0x10);
		LCD_WriteReg(0xD530,0x03);
		LCD_WriteReg(0xD531,0x33);
		LCD_WriteReg(0xD532,0x03);
		LCD_WriteReg(0xD533,0x6D);
		LCD_WriteReg(0xD600,0x00);
		LCD_WriteReg(0xD601,0x33);
		LCD_WriteReg(0xD602,0x00);
		LCD_WriteReg(0xD603,0x34);
		LCD_WriteReg(0xD604,0x00);
		LCD_WriteReg(0xD605,0x3A);
		LCD_WriteReg(0xD606,0x00);
		LCD_WriteReg(0xD607,0x4A);
		LCD_WriteReg(0xD608,0x00);
		LCD_WriteReg(0xD609,0x5C);
		LCD_WriteReg(0xD60A,0x00);
		LCD_WriteReg(0xD60B,0x81);

		LCD_WriteReg(0xD60C,0x00);
		LCD_WriteReg(0xD60D,0xA6);
		LCD_WriteReg(0xD60E,0x00);
		LCD_WriteReg(0xD60F,0xE5);
		LCD_WriteReg(0xD610,0x01);
		LCD_WriteReg(0xD611,0x13);
		LCD_WriteReg(0xD612,0x01);
		LCD_WriteReg(0xD613,0x54);
		LCD_WriteReg(0xD614,0x01);
		LCD_WriteReg(0xD615,0x82);
		LCD_WriteReg(0xD616,0x01);
		LCD_WriteReg(0xD617,0xCA);
		LCD_WriteReg(0xD618,0x02);
		LCD_WriteReg(0xD619,0x00);
		LCD_WriteReg(0xD61A,0x02);
		LCD_WriteReg(0xD61B,0x01);
		LCD_WriteReg(0xD61C,0x02);
		LCD_WriteReg(0xD61D,0x34);
		LCD_WriteReg(0xD61E,0x02);
		LCD_WriteReg(0xD61F,0x67);
		LCD_WriteReg(0xD620,0x02);
		LCD_WriteReg(0xD621,0x84);
		LCD_WriteReg(0xD622,0x02);
		LCD_WriteReg(0xD623,0xA4);
		LCD_WriteReg(0xD624,0x02);
		LCD_WriteReg(0xD625,0xB7);
		LCD_WriteReg(0xD626,0x02);
		LCD_WriteReg(0xD627,0xCF);
		LCD_WriteReg(0xD628,0x02);
		LCD_WriteReg(0xD629,0xDE);
		LCD_WriteReg(0xD62A,0x02);
		LCD_WriteReg(0xD62B,0xF2);
		LCD_WriteReg(0xD62C,0x02);
		LCD_WriteReg(0xD62D,0xFE);
		LCD_WriteReg(0xD62E,0x03);
		LCD_WriteReg(0xD62F,0x10);
		LCD_WriteReg(0xD630,0x03);
		LCD_WriteReg(0xD631,0x33);
		LCD_WriteReg(0xD632,0x03);
		LCD_WriteReg(0xD633,0x6D);
		//LV2 Page 0 enable
		LCD_WriteReg(0xF000,0x55);
		LCD_WriteReg(0xF001,0xAA);
		LCD_WriteReg(0xF002,0x52);
		LCD_WriteReg(0xF003,0x08);
		LCD_WriteReg(0xF004,0x00);
		//Display control
		LCD_WriteReg(0xB100, 0xCC);
		LCD_WriteReg(0xB101, 0x00);
		//Source hold time
		LCD_WriteReg(0xB600,0x05);
		//Gate EQ control
		LCD_WriteReg(0xB700,0x70);
		LCD_WriteReg(0xB701,0x70);
		//Source EQ control (Mode 2)
		LCD_WriteReg(0xB800,0x01);
		LCD_WriteReg(0xB801,0x03);
		LCD_WriteReg(0xB802,0x03);
		LCD_WriteReg(0xB803,0x03);
		//Inversion mode (2-dot)
		LCD_WriteReg(0xBC00,0x02);
		LCD_WriteReg(0xBC01,0x00);
		LCD_WriteReg(0xBC02,0x00);
		//Timing control 4H w/ 4-delay
		LCD_WriteReg(0xC900,0xD0);
		LCD_WriteReg(0xC901,0x02);
		LCD_WriteReg(0xC902,0x50);
		LCD_WriteReg(0xC903,0x50);
		LCD_WriteReg(0xC904,0x50);
		LCD_WriteReg(0x3500,0x00);
		LCD_WriteReg(0x3A00,0x55);  //16-bit/pixel
		LCD_WR_REG(0x1100);
		Delay_us(120);
		LCD_WR_REG(0x2900);
	}	 

	LCD_Display_Dir(0);		 	//默认为竖屏
	LCD_Clear();
	LCD_LED=1;					    //点亮背光
} 


#endif

